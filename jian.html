
    <!DOCTYPE html>
    <html>
    <head>
        <title>实操题pro</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                max-width: 900px;
                margin: 0 auto;
                padding: 20px;
                background-color: #f5f7fa;
                color: #333;
            }
            .header {
                background: linear-gradient(135deg, #6e8efb, #a777e3);
                color: white;
                padding: 20px;
                border-radius: 8px;
                margin-bottom: 30px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                text-align: center;
            }
            .question {
                margin-bottom: 25px;
                padding: 20px;
                background-color: white;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                transition: all 0.3s ease;
            }
            .question:hover {
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            }
            .question-number {
                font-weight: bold;
                color: #6e8efb;
                margin-bottom: 10px;
                font-size: 18px;
            }
            .question-text {
                white-space: pre-wrap;
                margin-bottom: 15px;
                line-height: 1.6;
            }
            .answer-section {
                margin-top: 15px;
                display: flex;
                gap: 20px;
            }
            .answer-textarea {
                flex: 1;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                resize: vertical;
                font-family: inherit;
                font-size: 14px;
                line-height: 1.5;
                min-height: 150px;
                background-color: #f8f9fa;
            }
            .reference-answer {
                flex: 1;
                display: flex;
                flex-direction: column;
            }
            .reference-btn {
                width: 100%;
                margin-bottom: 10px;
                padding: 10px 20px;
                background: linear-gradient(135deg, #6e8efb, #a777e3);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                transition: all 0.3s ease;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            }
            .reference-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            }
            .reference-content {
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                resize: vertical;
                font-family: inherit;
                font-size: 14px;
                line-height: 1.5;
                min-height: 150px;
                background-color: #f8f9fa;
                white-space: pre-wrap;
                overflow-y: auto;
                display: none;
            }
            .reference-content h4 {
                margin-top: 0;
                color: #6e8efb;
            }
            .button-group {
                display: flex;
                justify-content: center;
                gap: 15px;
                margin: 30px 0;
            }
            button {
                padding: 10px 20px;
                background: linear-gradient(135deg, #6e8efb, #a777e3);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                transition: all 0.3s ease;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            }
            button:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            }
            button:active {
                transform: translateY(0);
            }
            .answer-section {
                margin-top: 15px;
                display: flex;
                gap: 20px;
                align-items: flex-start;
            }

            .answer-textarea {
                flex: 1;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                resize: vertical;
                font-family: inherit;
                font-size: 14px;
                line-height: 1.5;
                min-height: 150px;
                max-height: 300px;
                overflow-y: auto;
                background-color: #f8f9fa;
            }

            .reference-answer {
                flex: 1;
                display: flex;
                flex-direction: column;
                height: 100%;
            }

            .reference-content {
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-family: inherit;
                font-size: 14px;
                line-height: 1.5;
                min-height: 150px;
                max-height: 300px;  /* 与答题框相同高度 */
                background-color: #f8f9fa;
                white-space: pre-wrap;
                overflow-y: auto;  /* 始终显示滚动条 */
                display: none;
                box-sizing: border-box;
            }

            .reference-content pre {
                margin: 0;
                white-space: pre-wrap;
                font-family: inherit;
                overflow-x: auto;
                max-width: 100%;
            }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>实操题pro</h1>
            <p>测试您的知识掌握程度</p>
        </div>

        <form id="quizForm">

    <div class="question" id="question_1">
        <div class="question-number">第 1 题</div>
        <div class="question-text">(简答题)
(1) 创建一个数值从 0 至 1，间隔为 0.01 的数组 arr1。
(2) 创建一个包含 101 个服从正态分布的随机数的数组 arr2。（注意：数组 arr2 为一维数组）
(3) 对数组 arr1 和数组 arr2 进行四则运算，并输出其结果。（四则运算包括加、减、乘、除运算）
(4) 对数组 arr2 进行简单的统计分析，并输出其结果。（统计分析包括对数组进行升序排序、求和、求均值、求标准差和求最小值操作）。
(5) 将数组 arr1 和数组 arr2 存储为当前工作路径下的一个二进制格式的文件 arr.npz。</div>
        <div class="answer-section" style="flex-direction: column; align-items: stretch;">
            <textarea id="answer_1" rows="6" placeholder="在此输入您的答案..." class="answer-textarea" style="width: 100%; box-sizing: border-box;"></textarea>
            <div class="reference-answer" style="margin-top: 10px; width: 100%;">
                <button type="button" onclick="toggleReferenceAnswer('1')" class="reference-btn" style="width: 150px; margin-bottom: 5px;">参考答案</button>
                <div id="reference_1" class="reference-content" style="width: 100%;">
                    <h4>参考答案：</h4>
                    <pre>1.
(1) 创建一个数值从 0 至 1，间隔为 0.01 的数组 arr1。(3 分)  

import numpy as np  
arr1 = np.arange(0, 1.01, 0.01)  

(2) 创建一个包含 101 个服从正态分布的随机数的数组 arr2。(注意：数组 arr2 为一维数组) (3 分)  

arr2 = np.random.randn(101)  

(3) 对数组 arr1 和数组 arr2 进行四则运算。(四则运算包括加、减、乘、除运算) (4 分)  

print('两数组之和为：\n', arr1 + arr2)  
print('两数组之差为：\n', arr1 - arr2)  
print('两数组之积为：\n', arr1 * arr2)  
print('两数组之商为：\n', arr1 / arr2)  

(4) 对数组 arr2 进行简单的统计分析。(统计分析包括对数组进行升序排序、求和、求均值、求标准差和求最小值操作) (6 分)。  

print('排序后数组为：', np.sort(arr2))  
print('数组的和为：', np.sum(arr2))  
print('数组的均值为：', np.mean(arr2))  
print('数组的标准差为：', np.std(arr2))  
print('数组的最小值为：', np.min(arr2))  

(5) 将数组 arr1 和数组 arr2 存储为当前工作路径下的一个二进制格式的文件 arr.npz。(4 分)  

np.savez('arr.npz', arr1, arr2)</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="question" id="question_2">
        <div class="question-number">第 2 题</div>
        <div class="question-text">(简答题)
(1) 读取数据文件iris.csv，存储为数据框iris，并将数据框的列名称从左至右依次修改为"sepal_length""sepal_width" "petal_length""petal_width""class"。
(2) 将数据框iris中"petal_length"列的第0行至第9行设置为缺失值。（注意：在Python中，索引为0开始）
(3) 将数据框iris中"petal_length"列的缺失值全部替换为1.0。
(4) 删除数据框iris中"class"列。
(5) 将数据框iris的前3行设置为缺失值。
(6) 删除数据框iris中存在缺失值的行。
(7) 重新设置数据框iris的行索引。
(8) 将数据框iris保存到当前工作路径下并命名为iris_new.csv。</div>
        <div class="answer-section" style="flex-direction: column; align-items: stretch;">
            <textarea id="answer_2" rows="6" placeholder="在此输入您的答案..." class="answer-textarea" style="width: 100%; box-sizing: border-box;"></textarea>
            <div class="reference-answer" style="margin-top: 10px; width: 100%;">
                <button type="button" onclick="toggleReferenceAnswer('2')" class="reference-btn" style="width: 150px; margin-bottom: 5px;">参考答案</button>
                <div id="reference_2" class="reference-content" style="width: 100%;">
                    <h4>参考答案：</h4>
                    <pre>2.
（1）读取数据文件iris.csv，存储为数据框iris，并将数据框的列名称从左至右依次修改为“sepal_length”“sepal__width”“petal_length”“petal_width”“class”。（3分）  

import pandas as pd  
iris = pd.read_csv('iris.csv', header=None)  
iris.columns = ['sepal_length','sepal_width', 'petal_length', 'petal_width', 'class']  

（2）将数据框iris中“petal_length”列的第0行至第9行设置为缺失值。（注意：在Python中，索引为0开始。）（3分）  

iris.loc[0:9, 'petal_length'] = None  

（3）将数据框iris中“petal_length”列的缺失值全部替换为1.0。（3分）  

iris['petal_length'].fillna(1.0, inplace=True)  

（4）删除数据框iris中“class”列。（2分）  

del iris['class']  

（5）将数据框iris的前3行设置为缺失值。（2分）  

iris.iloc[0:3, :] = None  

（6）删除数据框iris中存在缺失值的行。（2分）  

iris.dropna(how='any', inplace=True)  

（7）重新设置数据框iris的行索引。（3分）  

iris.reset_index(drop=True, inplace=True)  

（8）将数据框iris保存到当前工作路径下并命名为iris_new.csv。（2分）  

iris.to_csv('iris_new.csv')</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="question" id="question_3">
        <div class="question-number">第 3 题</div>
        <div class="question-text">(简答题)
(1) 读取数据文件 wine.csv，并储存为数据框 wine。
(2) 查询据框 wine 中是否存在缺失值。若存在缺失值，则需对其进行处理；反之，则无需处理。
(3) 在 wine 数据集中，"Class" 列为葡萄酒的类别，分别为 1、2 和 3。绘制各类别的数量占比饼图。
(4) 将数据框 wine 的数据和标签进行拆分，分别储存至数据框 wine_data 和数据框 wine_label。
(5) 将数据划分为训练集和测试集，训练集和测试集样本数比例为 8:2，并将训练集数据、测试集数据、训练集标签和测试集标签分别储存至数据框 wine_train、数据框 wine_test、数据框 wine_train_label 和数据框 wine_test_label。
(6) 构建聚类数目为 3 的 K - Means 模型，并命名为 kmeans。
(7) 对比真实标签和聚类标签，求取 FMI（FMI 为聚类模型的评价指标），并输出其结果。
(8) 当聚类数目为 2~10 类时，确定最优聚类数目。</div>
        <div class="answer-section" style="flex-direction: column; align-items: stretch;">
            <textarea id="answer_3" rows="6" placeholder="在此输入您的答案..." class="answer-textarea" style="width: 100%; box-sizing: border-box;"></textarea>
            <div class="reference-answer" style="margin-top: 10px; width: 100%;">
                <button type="button" onclick="toggleReferenceAnswer('3')" class="reference-btn" style="width: 150px; margin-bottom: 5px;">参考答案</button>
                <div id="reference_3" class="reference-content" style="width: 100%;">
                    <h4>参考答案：</h4>
                    <pre>3.
(1) 读取数据文件 wine.csv，并储存为数据框 wine。（1 分）  

import pandas as pd  
wine = pd.read_csv('wine.csv', encoding='gb18030')  

(2) 查询据框 wine 中是否存在缺失值。若存在缺失值，则需对其进行处理；反之，则无需处理。（2 分）  

print(wine.isnull().sum()) # 由此可知无空值，无需处理  

(3) 在 wine 数据集中，“Class” 列为葡萄酒的类别，分别为 1、2、3。绘制各类别的数量占比饼图。（4 分）  

wine_class = wine['Class'].value_counts()  
import matplotlib.pyplot as plt  
plt.rcParams['font.sans-serif'] = 'SimHei' # 正常显示中文  
plt.rcParams['axes.unicode_minus'] = False # 正常显示符号  
plt.pie(wine_class, labels=wine_class.index, autopct='%.2f%%') # 小数点个数  
plt.title('各红酒类别占比图')  
plt.show()  

(4) 将数据框 wine 的数据和标签进行拆分，分别储存至数据框 wine_data 和数据框 wine_label。（3 分）  

wine_data = wine.iloc[:, 1:14] # 数据  
wine_label = wine.iloc[:, 0] # 标签  

(5) 将数据划分为训练集和测试集，训练集和测试集样本数比例为 8:2，并将训练集数据、测试集数据、训练集标签和测试集标签分别储存至数据框 wine_train、数据框 wine_test、数据框 wine_train_label 和数据框 wine_test_label。（3 分）  

from sklearn.model_selection import train_test_split  
wine_train, wine_test, wine_train_label, wine_test_label = train_test_split(wine_data, wine_label, test_size=0.2, random_state=42)  

(6) 构建聚类数目为 3 的 K-Means 模型，并命名为 kmeans。（4 分）  

from sklearn.cluster import KMeans # 导入分类器库  
kmeans = KMeans(n_clusters=3, random_state=123).fit(wine_train) # 构建并训练模型  

(7) 对比真实标签和聚类标签，求取 FMI（FMI 为聚类模型的评价指标），并输出其结果。（4 分）  

from sklearn.metrics import fowlkes_mallows_score  
score = fowlkes_mallows_score(wine_train_label.tolist(), kmeans.labels_)  
print('wine 数据集的类中心为 3 时，其 FMI 的评价值为: %.4f'% score)  

(8) 当聚类数目为 2~10 类时，确定最优聚类数目。（4 分）  

for i in range(2, 11):  
    kmeans = KMeans(n_clusters=i, random_state=123).fit(wine_train)  
    score = fowlkes_mallows_score(wine_train_label, kmeans.labels_)  
    print('wine 数据集聚 %d 类 FMI 评价值为: %.4f' %(i, score))  
由此可知，最优聚类数目为 2</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="question" id="question_4">
        <div class="question-number">第 4 题</div>
        <div class="question-text">(简答题)
(1) 启动 Jupyter Notebook 创建一个 Notebook。
(2) 创建一个 8×8 的全 0 数组，并储存至数组 arr。
(3) 将数组 arr 的奇数行奇数列和偶数行偶数列的元素设置为 1。
(4) 将数组 arr 转换为矩阵 matr1。
(5) 将矩阵 matr1 转置为矩阵 matr2，并判断矩阵 matr1 与矩阵 matr2 是否完全相同。
(6) 将矩阵 matr2 存储为当前工作路径下的一个二进制格式的文件 matr2.npy。</div>
        <div class="answer-section" style="flex-direction: column; align-items: stretch;">
            <textarea id="answer_4" rows="6" placeholder="在此输入您的答案..." class="answer-textarea" style="width: 100%; box-sizing: border-box;"></textarea>
            <div class="reference-answer" style="margin-top: 10px; width: 100%;">
                <button type="button" onclick="toggleReferenceAnswer('4')" class="reference-btn" style="width: 150px; margin-bottom: 5px;">参考答案</button>
                <div id="reference_4" class="reference-content" style="width: 100%;">
                    <h4>参考答案：</h4>
                    <pre>4.
1) 启动 Jupyter Notebook 创建一个 Notebook。（2 分）  

(2) 创建一个 8×8 的全 0 数组，并储存至数组 arr。（3 分）  

import numpy as np  
arr = np.zeros((8, 8)) # 创建一个 8×8 数组  

(3) 将数组 arr 的奇数行奇数列和偶数行偶数列的元素设置为 1。（4 分）  

for i in range(8): # 按行循环  
    for j in range(8): # 按列循环  
        if (i + j) % 2 == 0: # 找出行索引与列索引之和为偶数的元素  
            arr[i][j] = 1 # 将其设置为 1  

(4) 将数组 arr 转换为矩阵 matr1。（2 分）  

matr1 = np.mat(arr)  

(5) 将矩阵 matr1 转置为矩阵 matr2, 并判断矩阵 matr1 与矩阵 matr2 是否完全相同。（3 分）  

matr2 = matr1.T  
print((matr1 == matr2).all())  

(6) 将矩阵 matr2 存储为当前工作路径下的一个二进制格式的文件 matr2.npy。（2 分）  

np.save('matr2.npy', matr2)</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="question" id="question_5">
        <div class="question-number">第 5 题</div>
        <div class="question-text">(简答题)
(1) 读取数据文件 job_info.csv，并储存为数据框 job_info。
(2) 将数据框 job_info 的列名称从左至右依次修改为 "公司""岗位""工作地点""工资""发布日期"。
(3) 统计数据中需求最多的岗位招聘，并输出其结果。
(4) 获取数据中 9 月 3 日发布的招聘信息，并输出其结果。
(5) 获取工作地点在深圳的数据分析师招聘信息，并输出其结果。
(6) 获取在 "工资" 列中，以 "千 / 月" 或 "千 / 年" 或 "万 / 月" 或 "万 / 年" 结尾的数据所在的行的数据，并储存至数据框 job_info_new。
(7) 根据 "工资" 列，在数据框 job_info_new 中，新增最低工资和最高工资两列，列名分别设置为 "最低工资（元 / 月）" 和 "最高工资（元 / 月）"。（注意：这两列数据的单位是 "元 / 月"，例如：若 2 - 2.5 万 / 月，则最低工资为 20000，最高工资为 25000。）</div>
        <div class="answer-section" style="flex-direction: column; align-items: stretch;">
            <textarea id="answer_5" rows="6" placeholder="在此输入您的答案..." class="answer-textarea" style="width: 100%; box-sizing: border-box;"></textarea>
            <div class="reference-answer" style="margin-top: 10px; width: 100%;">
                <button type="button" onclick="toggleReferenceAnswer('5')" class="reference-btn" style="width: 150px; margin-bottom: 5px;">参考答案</button>
                <div id="reference_5" class="reference-content" style="width: 100%;">
                    <h4>参考答案：</h4>
                    <pre>5.
(1) 读取数据文件 job_info.csv，并储存为数据框 job_info。（2 分）  

import pandas as pd  
import re  
job_info = pd.read_csv('job_info.csv', encoding='GBK', header=None)  
job_info.head()  

(2) 将数据框 job_info 的列名称从左至右依次修改为“公司”“岗位”“工作地点”“工资”“发布日期”。（2 分）  

job_info.columns = ['公司', '岗位', '工作地点', '工资', '发布日期']  
job_info.head()  

(3) 统计数据中需求最多的岗位招聘，并输出其结果。（2 分）  

print(job_info['岗位'].value_counts().index[0])  

(4) 获取数据中 9 月 3 日发布的招聘信息，并输出其结果。（3 分）  

print(job_info[job_info['发布日期'] == '09-03'])  

(5) 获取工作地点在深圳的数据分析师招聘信息，并输出其结果。（3 分）  

job_info.loc[(job_info['工作地点'].apply(lambda x: '深圳' in x)) & (job_info['岗位'] == '数据分析师'), :]  

(6) 获取在“工资”列中，以“千/月”或“千/年”或“万/月”或“万/年”结尾的数据所在的行的数据，并储存至数据框 job_info_new。（3 分）  

job_info['工资'].str[-1].value_counts()  
job_info['工资'].str[-3].value_counts()  
index1 = job_info['工资'].str[-1].apply(lambda x: x in ['月', '年'])  
index2 = job_info['工资'].str[-3].apply(lambda x: x in ['千', '万'])  
job_info_new = job_info[index1 & index2]  
job_info_new.shape  

(7) 根据“工资”列，在数据框 job_info_new 中，新增最低工资和最高工资两列，列名分别设置为“最低工资（元/月）”和“最高工资（元/月）”。（注意：这两列数据的单位是“元/月”，例如：若 2-2.5 万/月，则最低工资为 20000，最高工资为25000。）（5 分）  

def get_max_min_value(x):  
    try:  
        if x[-3] == '万':  
            a = [float(i) * 10000 for i in re.findall('\d+\.?\d*', x)]  
        elif x[-3] == '千':  
            a = [float(i) * 1000 for i in re.findall('\d+\.?\d*', x)]  
        if x[-1] == '年':  
            a = [i / 12 for i in a]  
    except:  
        pass  
    return a  
salary = job_info_new['工资'].apply(get_max_min_value)  
job_info_new['最低工资(元/月)'] = salary.apply(lambda x: x[0])  
job_info_new['最高工资(元/月)'] = salary.apply(lambda x: x[1])</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="question" id="question_6">
        <div class="question-number">第 6 题</div>
        <div class="question-text">(简答题)
(1) 使用 sklearn 库加载鸢尾花数据和数据标签，将鸢尾花数据储存至数据框 data，数据标签储存至数据框 label。
(2) 统计数据中鸢尾花的类别数，并输出其结果。
(3) 以花萼长度为 x 轴，花萼宽度为 y 轴，绘制并展示散点图。
(4) 将加载好的鸢尾花数据集划分成训练集和测试集两部分，训练集和测试集样本数比例为 8:2，并将训练集数据、测试集数据、训练集标签和测试集标签分别储存至数据框 x_train，数据框 x_test，数据框 y_train 和数据框 y_test。
(5) 对数据框 x_train 和数据框 x_test 进行离差标准化，将标准化后的训练集和测试集数据分别储存至数据框 scaler_x_train 和数据框 scaler_x_test。（注意：测试集数据需使用和训练集数据相同的规则进行标准化。）
(6) 构建决策树分类模型，命名为 model，并进行模型训练。
(7) 对构建的模型进行性能评估，并输出其结果。（性能评估包括计算精确率、召回率和 F1 值等分类评估指标。）</div>
        <div class="answer-section" style="flex-direction: column; align-items: stretch;">
            <textarea id="answer_6" rows="6" placeholder="在此输入您的答案..." class="answer-textarea" style="width: 100%; box-sizing: border-box;"></textarea>
            <div class="reference-answer" style="margin-top: 10px; width: 100%;">
                <button type="button" onclick="toggleReferenceAnswer('6')" class="reference-btn" style="width: 150px; margin-bottom: 5px;">参考答案</button>
                <div id="reference_6" class="reference-content" style="width: 100%;">
                    <h4>参考答案：</h4>
                    <pre>6.
(1) 使用 sklearn 库加载鸢尾花数据和数据标签，将鸢尾花数据储存至数据框 data，数据标签储存至数据框 label。(3 分)  

from sklearn.datasets import load_iris  
iris = load_iris()  
data = iris['data']  
label = iris['target']  

(2) 统计数据中鸢尾花的类别数，并输出其结果。（3 分）  

print(len(set(label)))  

(3) 以花萼长度为 x 轴，花萼宽度为 y 轴，绘制并展示散点图。（3 分）  

import matplotlib.pyplot as plt  
plt.scatter(data[:, 0], data[:, 1])  
plt.show()  

(4) 将加载好的鸢尾花数据集划分成训练集和测试集两部分，训练集和测试集样本数比例为 8:2，并将训练集数据、测试集数据、训练集标签和测试集标签分别储存至数据框 x_train，数据框 x_test，数据框 y_train 和数据框 y_test。（4分）  

from sklearn.model_selection import train_test_split  
x_train, x_test, y_train, y_test = train_test_split(data, label, test_size=0.2)  

(5) 对数据框 x_train 和数据框 x_test 进行离差标准化，将标准化后的训练集和测试集数据分别储存至数据框 scaler_x_train 和数据框 scaler_x_test。（注意：测试集数据需使用和训练集数据相同的规则进行标准化。）（4 分）  

from sklearn.preprocessing import MinMaxScaler  
scaler = MinMaxScaler().fit(x_train)  
scaler_x_train = scaler.transform(x_train)  
scaler_x_test = scaler.transform(x_test)  

(6) 构建决策树分类模型，命名为 model，并进行模型训练。（4 分）  

from sklearn.tree import DecisionTreeClassifier  
model = DecisionTreeClassifier()  
model.fit(scaler_x_train, y_train)  

(7) 对构建的模型进行性能评估，并输出其结果。（性能评估包括计算精确率、召回率和 F1 值等分类评估指标。）（4分）  

from sklearn.metrics import classification_report # 模型评估  
pre = model.predict(scaler_x_test)  
res = classification_report(y_test, pre)  
print(res)</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="question" id="question_7">
        <div class="question-number">第 7 题</div>
        <div class="question-text">(简答题)
(1) 启动 Jupyter Notebook 创建一个 Notebook。
(2) 随机生成 100 个二维坐标点，并储存至数组 arr1。
(3) 计算各样本点之间的欧氏距离，并储存至数组 arr2。
(4) 将数组 arr2 的形状转换为（100, 100）。
(5) 将数组 arr2 存储为当前工作路径下的一个二进制格式的文件 arr2.npy。</div>
        <div class="answer-section" style="flex-direction: column; align-items: stretch;">
            <textarea id="answer_7" rows="6" placeholder="在此输入您的答案..." class="answer-textarea" style="width: 100%; box-sizing: border-box;"></textarea>
            <div class="reference-answer" style="margin-top: 10px; width: 100%;">
                <button type="button" onclick="toggleReferenceAnswer('7')" class="reference-btn" style="width: 150px; margin-bottom: 5px;">参考答案</button>
                <div id="reference_7" class="reference-content" style="width: 100%;">
                    <h4>参考答案：</h4>
                    <pre>7.
（1）启动 Jupyter Notebook 创建一个 Notebook。（2 分）  

（2）随机生成 100 个二维坐标点，并储存至数组 arr1。（4 分）  

import numpy as np  
x = np.linspace(0, 10, 100)  
y = np.linspace(10, 20, 100)  
arr1 = np.array((x, y)).T # 数组 arr1 形状为（100, 2）  

（3）计算各样本点之间的欧氏距离，并储存至数组 arr2。（4 分）  

arr2 = []  
for i in range(len(arr1)):  
    for j in range(len(arr1)):  
        a = np.sqrt((arr1[i, 0] - arr1[j, 0]) ** 2 + (arr1[i, 1] - arr1[j, 1]) ** 2)  
        arr2.append(a)  
arr2 = np.array(arr2)  

（4）将数组 arr2 的形状转换为(100, 100)。（3 分）  

arr2 = arr2.reshape(100, 100)  

（5）将数组 arr2 存储为当前工作路径下的一个二进制格式的文件 arr2.npy。（2 分）  

np.save('arr2.npy', arr2)</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="question" id="question_8">
        <div class="question-number">第 8 题</div>
        <div class="question-text">(简答题)
(1) 读取数据文件 data.csv，并储存为数据框 data。
(2) 将数据框 data 转换为行索引为用户编号、列索引为时间、值为用户每日用电量的数据透视表 data_new。
(3) 采用四分位法对透视表 data_new 中的异常数据进行识别并处理。
(4) 构造特征 1：统计每个用户用电数据的基本统计量（基本统计量包括最大值、最小值、均值、中位数），并将结果储存至数据feature1。
(5) 构造特征 2：将每个用户用电数据按日差分后，求取基本统计量（基本统计量包括最大值、最小值、均值、中位数），将结果储存至数据框 feature2。
(6) 构造特征 3：求每个用户的 5%分位数，并将结果储存至数据框 feature3。
(7) 构造特征 4：统计每个用户的日用电量在其最大值 0.9 倍以上的次数，并将结果储存至数据框feature4。
(8) 合并特征 1、特征 2、特征 3 和特征 4，并储存至数据框 feature。
(9) 将数据框 feature 保存到当前工作路径下并命名为 feature.csv。</div>
        <div class="answer-section" style="flex-direction: column; align-items: stretch;">
            <textarea id="answer_8" rows="6" placeholder="在此输入您的答案..." class="answer-textarea" style="width: 100%; box-sizing: border-box;"></textarea>
            <div class="reference-answer" style="margin-top: 10px; width: 100%;">
                <button type="button" onclick="toggleReferenceAnswer('8')" class="reference-btn" style="width: 150px; margin-bottom: 5px;">参考答案</button>
                <div id="reference_8" class="reference-content" style="width: 100%;">
                    <h4>参考答案：</h4>
                    <pre>8.
（1）读取数据文件 data.csv，并储存为数据框 data。（2 分）  

import pandas as pd  
data = pd.read_csv('data.csv', parse_dates=['DATA_DATE'], encoding='gbk')  

（2）将数据框 data 转换为行索引为用户编号、列索引为时间、值为用户每日用电量的数据透视表 data_new。（2 分）  

data_new = pd.pivot_table(data=data, values='KWH', index='CONS_NO', columns='DATA_DATE')  

（3）采用四分位法对透视表 data_new 中的异常数据进行识别并处理。（4 分）  

def clear_(x=None):  
    QL = x.quantile(0.25) # 下四分位数  
    QU = x.quantile(0.75) # 上四分位数  
    IQR = QU – QL # 四分位距  
    x[((x > QU + 1.5 * IQR) | (x < QL - 1.5 * IQR))] = None  
    return x  
data_new.apply(clear_, axis=0)  

（4）构造特征 1：统计每个用户用电数据的基本统计量（基本统计量包括最大值、最小值、均值、中位数），并将结果储存至数据框 feature1。（2 分）  

feature1 = data_new.agg(['max', 'min', 'mean', 'median'], axis=1)  

（5）构造特征 2：将每个用户用电数据按日差分后，求取基本统计量（基本统计量包括最大值、最小值、均值、中位数），将结果储存至数据框 feature2。（2 分）  

feature2 = data_new.diff(axis=1).agg(['max', 'min', 'mean', 'median'], axis=1)  

（6）构造特征 3：求每个用户的 5%分位数，并将结果储存至数据框 feature3。（2 分）  

feature3 = data_new.quantile(0.05, axis=1)  

（7）构造特征 4：统计每个用户的日用电量在其最大值 0.9 倍以上的次数，并将结果储存至数据框 feature4。（2 分）  

feature4 = data_new.apply(lambda x: sum(x > x.max() * 0.9), axis=1)  

（8）合并特征 1、特征 2、特征 3 和特征 4，并储存至数据框 feature。（2 分）  

feature = pd.concat([feature1, feature2, feature3, feature4], axis=0)  

（9）将数据框 feature 保存到当前工作路径下并命名为 feature.csv。（2 分）  

feature.to_csv('feature.csv')</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="question" id="question_9">
        <div class="question-number">第 9 题</div>
        <div class="question-text">(简答题)
(1) 读取数据文件 titanic.csv，并储存为数据框 titanic。
(2) 计算乘客生还人数，并输出其结果。
(3) 绘制男女乘客比例饼图，并添加标题"男女乘客比例饼图"。
(4) 绘制船票价格直方图，并添加 x 轴标题"船票价格"和 y 轴标题"频次"。（注意：需先对"船票价格"进行升序排序。）
(5) 在数据框 titanic 中，新增一列为家庭人数，并将列名设置为"familysize"。
(6) 修改数据框 titanic 的"Sex"列，使用数值"1"和"0"分别代替"Sex"列中的"male"和"female"。
(7) 根据"Pclass"、"Sex"和"familysize"这三个特征预测乘客是否生还。将数据集划分成训练集和测试集两部分，训练集和测试集样本数例为 8:2。
(8) 构建 KNN 模型，命名为 clf，并进行模型训练。
(9) 使用测试集数据进行模型预测，并将结果储存至数组 pre。
(10) 对构建的模型进行性能评估，并输出其结果。（性能评估包括计算精确率、召回率和 F1 值等分类评估指标。）</div>
        <div class="answer-section" style="flex-direction: column; align-items: stretch;">
            <textarea id="answer_9" rows="6" placeholder="在此输入您的答案..." class="answer-textarea" style="width: 100%; box-sizing: border-box;"></textarea>
            <div class="reference-answer" style="margin-top: 10px; width: 100%;">
                <button type="button" onclick="toggleReferenceAnswer('9')" class="reference-btn" style="width: 150px; margin-bottom: 5px;">参考答案</button>
                <div id="reference_9" class="reference-content" style="width: 100%;">
                    <h4>参考答案：</h4>
                    <pre>9.
（1）读取数据文件 titanic.csv，并储存为数据框 titanic。（1 分）  

import numpy as np  
import pandas as pd  
titanic = pd.read_csv('titanic.csv')  

（2）计算乘客生还人数，并输出其结果。（2 分）  

titanic['Survived'].sum()  

（3）绘制男女乘客比例饼图，并添加标题“男女乘客比例饼图”。（3 分）  

import matplotlib.pyplot as plt  
plt.rcParams['font.sans-serif'] = 'SimHei' # 正常显示中文  
plt.rcParams['axes.unicode_minus'] = False # 正常显示符号  
sex_ = titanic['Sex'].value_counts()  
plt.pie(sex_.values, labels=['Male', 'Female'], autopct='%1.1f%%', startangle=90)  
plt.title('男女乘客比例饼图')  
plt.show()  

（4）绘制船票价格直方图，并添加 x 轴标题“船票价格”和 y 轴标题“频次”。（注意：需先对“船票价格”进行升序排序。）（3 分）  

df = titanic['fare'].sort_values(ascending=False)  
plt.figure()  
plt.hist(df, bins=(np.arange(0, 550, 10)))  
plt.xlabel('船票价格')  
plt.ylabel('频次')  
plt.title('船票价格直方图')  
plt.show()  

（5）在数据框 titanic 中，新增一列为家庭人数，并将列名设置为“familysize”。（2 分）  

titanic['familysize'] = titanic.loc[:, 'SibSp'] + titanic.loc[:, 'Parch'] + 1  

（6）修改数据框 titanic 的“Sex”列，使用数值“1”和“0”分别代替“Sex”列中的“male”和“female”。（2分）  

titanic['Sex'] = titanic['Sex'].map({'female':0, 'male':1}).astype(int)  

（7）将数据集划分成训练集和测试集两部分，训练集和测试集样本数比例为 8:2，并将训练集数据、测试集数据、训练集标签和测试集标签分别储存至数据框 x_train，数据框 x_test，数据框 y_train 和数据框 y_test。（4 分）  

from sklearn.model_selection import train_test_split  
x = titanic.loc[:, ['Pclass', 'Sex', 'familysize']]  
y = titanic.loc[:, 'Survived']  
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)  

（8）构建 KNN 模型，命名为 clf，并进行模型训练。（4 分）  

from sklearn import neighbors  
clf = neighbors.KNeighborsClassifier(n_neighbors=20)  
clf.fit(x_train, y_train) # KNN 训练  

（9）使用测试集数据进行模型预测，并将结果储存至数组 pre。（2 分）  

pre = clf.predict(x_test) # 模型预测  

（10）对构建的模型进行性能评估，并输出其结果。（性能评估包括计算精确率、召回率和 F1 值等分类评估指标。）（2 分）  

from sklearn.metrics import classification_report  
res = classification_report(y_test, pre) # 模型评估</pre>
                </div>
            </div>
        </div>
    </div>


            <div class="button-group">
                <button type="button" onclick="resetQuiz()">重做</button>
                <button type="button" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">返回顶部</button>
            </div>
        </form>

        <script>
            function toggleReferenceAnswer(questionId) {
                const referenceDiv = document.getElementById('reference_' + questionId);
                referenceDiv.style.display = referenceDiv.style.display === 'none' ? 'block' : 'none';
            }

            function resetQuiz() {
                document.getElementById('quizForm').reset();
                document.querySelectorAll('.reference-content').forEach(el => {
                    el.style.display = 'none';
                });
                window.scrollTo({top: 0, behavior: 'smooth'});
            }
        </script>
    </body>
    </html>
